# Lego PoweredUP App

Check out [the client](https://github.com/Nickzster/lego-poweredup-app-client) portion to see the client details.

This is the server component to my Lego PoweredUP app. You can actually download both the client & server, turn on your trains and use it now if you want!

This readme will describe the story behind this application and how it is implemented. Feel free to fork / use this code to your own use!

## Introduction

I am a software engineer who also happens to be a passionate collector of lego, which includes their impressive line-up of train models and the PoweredUP functionality of them. However, I couldn't help but want more out of these trains. To be honest, I wanted to build a mega train with 3 or 4 engines so it can push around a ten foot train! But I'd have to use multiple controllers or LEGO's app, which doesn't provide these capabilities.

But then I stumbled across [nathankellenicki/node-poweredup](https://github.com/nathankellenicki/node-poweredup), and suddenly the possibilties were endless!

Needless to say I had many iterations of this project, and this is the final iteration that I came up with that provided me the most capabilities and provided me the most flexibility to expand on.

## The Requirements

I knew up front that I wanted to be able to do the following with my train collection:

- Be able to hook all of them up independently, and control them independently
- Be able to somehow 'link' them all together into a mega-train, and operate that ten-foot train like I was talking about earlier.
- Be able to control everything in real time.

Needless to say, this project is the product of those requirements.

## Prototyping

I started first with playing with the `node-poweredup` library, as I knew this library was going to be doing the heavy lifting of handling the bluetooth connections, and the motor commands. It turns out it is pretty nice and straightforward to use! Once I was able to understand how the library worked, I was able to build the logical abstractions on top of it to fullfil my requirements.

After many other prototypes, I came up with the final design. From here on out, I will document to the best of my abilities the design & how its implemented. I will start from the hardware, and work my way forwards to the client.

## Concepts

**Motor** - This component (implemented as a simple class) represents the physical hardware, the operations to control the hardware, and its state.

**Remote** - This component (implemented as a simple class too) represents a 'virtual' abstraction, decoupling the operations from the hardware. This is the key to being able to process commands (for example, `increaseMotorPower`, `decreaseMotorPower`, and `brake` operations) to multiple remotes concurrently, and is the key to being able to 'link' the engines together. The main element of this component is an array of motors in which it performs actions on.

**Controller** - This component is a React Component that represents the PoweredUP remote in virtual form.

## The glue that ties everything together

I knew these three components were not enough, and needed an easy way to extend the capabilities of the interactions between these components. Enter the 'glue' of these components: the WebSocket server (`WSServer` for the server, and `PUClient` for the client), and the `EventPipeline`.

**The WebSocket Server** - This was the key to achieving the real time capabilities I wanted to have with this project. For those who aren't familiar, they can read about [WebSockets here.](https://en.wikipedia.org/wiki/WebSocket). The TL;DR is that WebSockets allow asynchronous communcation between multiple clients and servers. One of the original prototypes was actually an http server using polling, which wasn't very optimal.

**The EventPipeline** - I needed a robust way to handle commands coming from the client, and wanted to be able to extend it with minimal work, which is how I came up with the `EventPipeline`. There are two types of messages in this implementation:

- `MessageForServer`: The message that is sent to the server, generated by the client. This message contains a command type, and a payload containing the details of that command.
- `MessageForClient`: The message that is sent to the client, generated by the server. This message contains the entire state of the application, to which the client renders. I knew this client wasn't going to go past five connections, so I figured it was safe to re-render the entire application state on every change rather than only the deltas.

The `EventPipeline` uses the [chain of responsibility](https://refactoring.guru/design-patterns/chain-of-responsibility) under the hood. It implements multiple handlers that check the message's type, and either handles it directly and generates a `MessageForClient` object, or delegates to the next handler.

## Action Items and other Opportunities for Improvement

- Currently, the state of all motors and all remotes are stored using a hash table (`CustomMap`). I feel that a structural pattern could be better used here to extend the capabilties of these components.
- The UX could be better, but it does a really good job at representing the state of each motor, and using controllers to interact with the motors.
- The connection connectivity is a little limited. It would be nice to have disconnect logic so that the server can keep running reliably.
- Reconsider the client-server architecture and build it as a single app for easier on-boarding

## Conclusion

And that's how this app works! There's more granular details I left out in this description, but is located in the code. I hope you enjoyed the story behind this application! Feel free to use it however you want!

-Nick
